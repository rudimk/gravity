// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: agent.proto

package proto

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ExecOutput_FD int32

const (
	ExecOutput_STDOUT ExecOutput_FD = 0
	ExecOutput_STDERR ExecOutput_FD = 1
)

var ExecOutput_FD_name = map[int32]string{
	0: "STDOUT",
	1: "STDERR",
}

var ExecOutput_FD_value = map[string]int32{
	"STDOUT": 0,
	"STDERR": 1,
}

func (x ExecOutput_FD) String() string {
	return proto.EnumName(ExecOutput_FD_name, int32(x))
}

func (ExecOutput_FD) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{6, 0}
}

type LogEntry_Level int32

const (
	LogEntry_Debug LogEntry_Level = 0
	LogEntry_Info  LogEntry_Level = 1
	LogEntry_Warn  LogEntry_Level = 2
	LogEntry_Error LogEntry_Level = 3
)

var LogEntry_Level_name = map[int32]string{
	0: "Debug",
	1: "Info",
	2: "Warn",
	3: "Error",
}

var LogEntry_Level_value = map[string]int32{
	"Debug": 0,
	"Info":  1,
	"Warn":  2,
	"Error": 3,
}

func (x LogEntry_Level) String() string {
	return proto.EnumName(LogEntry_Level_name, int32(x))
}

func (LogEntry_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{7, 0}
}

// ShutdownRequest describes a request to shut down a report RPC agent
type ShutdownRequest struct {
	// Cleanup specifies whether this should invoke the cleanup handler
	Cleanup              bool     `protobuf:"varint,1,opt,name=cleanup,proto3" json:"cleanup,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShutdownRequest) Reset()         { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()    {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{0}
}
func (m *ShutdownRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShutdownRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShutdownRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShutdownRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShutdownRequest.Merge(m, src)
}
func (m *ShutdownRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShutdownRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShutdownRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShutdownRequest proto.InternalMessageInfo

func (m *ShutdownRequest) GetCleanup() bool {
	if m != nil {
		return m.Cleanup
	}
	return false
}

type CommandArgs struct {
	// Args specify the command to run
	Args []string `protobuf:"bytes,1,rep,name=args,proto3" json:"args,omitempty"`
	// SelfCommand specifies whether the agent's binary
	// should execute the command given with args
	SelfCommand bool `protobuf:"varint,2,opt,name=self_command,json=selfCommand,proto3" json:"self_command,omitempty"`
	// Env sets the environment for the command
	Env                  map[string]string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CommandArgs) Reset()         { *m = CommandArgs{} }
func (m *CommandArgs) String() string { return proto.CompactTextString(m) }
func (*CommandArgs) ProtoMessage()    {}
func (*CommandArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{1}
}
func (m *CommandArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandArgs.Merge(m, src)
}
func (m *CommandArgs) XXX_Size() int {
	return m.Size()
}
func (m *CommandArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CommandArgs proto.InternalMessageInfo

func (m *CommandArgs) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandArgs) GetSelfCommand() bool {
	if m != nil {
		return m.SelfCommand
	}
	return false
}

func (m *CommandArgs) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

// Message is a union of various subtypes of event stream
type Message struct {
	// Types that are valid to be assigned to Element:
	//	*Message_ExecStarted
	//	*Message_ExecCompleted
	//	*Message_ExecOutput
	//	*Message_LogEntry
	//	*Message_Error
	Element              isMessage_Element `protobuf_oneof:"element"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{2}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type isMessage_Element interface {
	isMessage_Element()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_ExecStarted struct {
	ExecStarted *ExecStarted `protobuf:"bytes,1,opt,name=exec_started,json=execStarted,proto3,oneof"`
}
type Message_ExecCompleted struct {
	ExecCompleted *ExecCompleted `protobuf:"bytes,2,opt,name=exec_completed,json=execCompleted,proto3,oneof"`
}
type Message_ExecOutput struct {
	ExecOutput *ExecOutput `protobuf:"bytes,3,opt,name=exec_output,json=execOutput,proto3,oneof"`
}
type Message_LogEntry struct {
	LogEntry *LogEntry `protobuf:"bytes,4,opt,name=log_entry,json=logEntry,proto3,oneof"`
}
type Message_Error struct {
	Error *Error `protobuf:"bytes,5,opt,name=error,proto3,oneof"`
}

func (*Message_ExecStarted) isMessage_Element()   {}
func (*Message_ExecCompleted) isMessage_Element() {}
func (*Message_ExecOutput) isMessage_Element()    {}
func (*Message_LogEntry) isMessage_Element()      {}
func (*Message_Error) isMessage_Element()         {}

func (m *Message) GetElement() isMessage_Element {
	if m != nil {
		return m.Element
	}
	return nil
}

func (m *Message) GetExecStarted() *ExecStarted {
	if x, ok := m.GetElement().(*Message_ExecStarted); ok {
		return x.ExecStarted
	}
	return nil
}

func (m *Message) GetExecCompleted() *ExecCompleted {
	if x, ok := m.GetElement().(*Message_ExecCompleted); ok {
		return x.ExecCompleted
	}
	return nil
}

func (m *Message) GetExecOutput() *ExecOutput {
	if x, ok := m.GetElement().(*Message_ExecOutput); ok {
		return x.ExecOutput
	}
	return nil
}

func (m *Message) GetLogEntry() *LogEntry {
	if x, ok := m.GetElement().(*Message_LogEntry); ok {
		return x.LogEntry
	}
	return nil
}

func (m *Message) GetError() *Error {
	if x, ok := m.GetElement().(*Message_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_ExecStarted)(nil),
		(*Message_ExecCompleted)(nil),
		(*Message_ExecOutput)(nil),
		(*Message_LogEntry)(nil),
		(*Message_Error)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// element
	switch x := m.Element.(type) {
	case *Message_ExecStarted:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExecStarted); err != nil {
			return err
		}
	case *Message_ExecCompleted:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExecCompleted); err != nil {
			return err
		}
	case *Message_ExecOutput:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExecOutput); err != nil {
			return err
		}
	case *Message_LogEntry:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogEntry); err != nil {
			return err
		}
	case *Message_Error:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Element has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 1: // element.exec_started
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExecStarted)
		err := b.DecodeMessage(msg)
		m.Element = &Message_ExecStarted{msg}
		return true, err
	case 2: // element.exec_completed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExecCompleted)
		err := b.DecodeMessage(msg)
		m.Element = &Message_ExecCompleted{msg}
		return true, err
	case 3: // element.exec_output
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExecOutput)
		err := b.DecodeMessage(msg)
		m.Element = &Message_ExecOutput{msg}
		return true, err
	case 4: // element.log_entry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogEntry)
		err := b.DecodeMessage(msg)
		m.Element = &Message_LogEntry{msg}
		return true, err
	case 5: // element.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Element = &Message_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// element
	switch x := m.Element.(type) {
	case *Message_ExecStarted:
		s := proto.Size(x.ExecStarted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_ExecCompleted:
		s := proto.Size(x.ExecCompleted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_ExecOutput:
		s := proto.Size(x.ExecOutput)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_LogEntry:
		s := proto.Size(x.LogEntry)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ExecStarted is sent when local command starts to execute
type ExecStarted struct {
	// Seq specifies the command ID. Unique only in the current call scope
	Seq int32 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// Args describes the running command
	Args []string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	// Env defines the environment of the running command
	Env                  []string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecStarted) Reset()         { *m = ExecStarted{} }
func (m *ExecStarted) String() string { return proto.CompactTextString(m) }
func (*ExecStarted) ProtoMessage()    {}
func (*ExecStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{3}
}
func (m *ExecStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecStarted.Merge(m, src)
}
func (m *ExecStarted) XXX_Size() int {
	return m.Size()
}
func (m *ExecStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecStarted.DiscardUnknown(m)
}

var xxx_messageInfo_ExecStarted proto.InternalMessageInfo

func (m *ExecStarted) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ExecStarted) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ExecStarted) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

// ExecComplete is sent when command completes
type ExecCompleted struct {
	// Seq specifies the command ID. Unique only in the current call scope
	Seq int32 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// ExitCode is the exit code command exited with
	ExitCode int32 `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// Error specifies the command execution error
	Error                *Error   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecCompleted) Reset()         { *m = ExecCompleted{} }
func (m *ExecCompleted) String() string { return proto.CompactTextString(m) }
func (*ExecCompleted) ProtoMessage()    {}
func (*ExecCompleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{4}
}
func (m *ExecCompleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecCompleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecCompleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecCompleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecCompleted.Merge(m, src)
}
func (m *ExecCompleted) XXX_Size() int {
	return m.Size()
}
func (m *ExecCompleted) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecCompleted.DiscardUnknown(m)
}

var xxx_messageInfo_ExecCompleted proto.InternalMessageInfo

func (m *ExecCompleted) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ExecCompleted) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ExecCompleted) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

// Error encapsulates error stack
type Error struct {
	// Messages specifies the error message
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Traces lists stack traces
	Traces               []string `protobuf:"bytes,2,rep,name=traces,proto3" json:"traces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{5}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetTraces() []string {
	if m != nil {
		return m.Traces
	}
	return nil
}

// ExecOutput represents output of a running command
type ExecOutput struct {
	Seq                  int32         `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Fd                   ExecOutput_FD `protobuf:"varint,2,opt,name=fd,proto3,enum=proto.ExecOutput_FD" json:"fd,omitempty"`
	Data                 []byte        `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ExecOutput) Reset()         { *m = ExecOutput{} }
func (m *ExecOutput) String() string { return proto.CompactTextString(m) }
func (*ExecOutput) ProtoMessage()    {}
func (*ExecOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{6}
}
func (m *ExecOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecOutput.Merge(m, src)
}
func (m *ExecOutput) XXX_Size() int {
	return m.Size()
}
func (m *ExecOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ExecOutput proto.InternalMessageInfo

func (m *ExecOutput) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ExecOutput) GetFd() ExecOutput_FD {
	if m != nil {
		return m.Fd
	}
	return ExecOutput_STDOUT
}

func (m *ExecOutput) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type LogEntry struct {
	Message              string            `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Fields               map[string]string `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Level                LogEntry_Level    `protobuf:"varint,3,opt,name=level,proto3,enum=proto.LogEntry_Level" json:"level,omitempty"`
	Traces               []string          `protobuf:"bytes,4,rep,name=traces,proto3" json:"traces,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LogEntry) Reset()         { *m = LogEntry{} }
func (m *LogEntry) String() string { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()    {}
func (*LogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{7}
}
func (m *LogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntry.Merge(m, src)
}
func (m *LogEntry) XXX_Size() int {
	return m.Size()
}
func (m *LogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntry proto.InternalMessageInfo

func (m *LogEntry) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *LogEntry) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *LogEntry) GetLevel() LogEntry_Level {
	if m != nil {
		return m.Level
	}
	return LogEntry_Debug
}

func (m *LogEntry) GetTraces() []string {
	if m != nil {
		return m.Traces
	}
	return nil
}

// UninstallRequest is request to uninstall the system on remote node
type UninstallRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UninstallRequest) Reset()         { *m = UninstallRequest{} }
func (m *UninstallRequest) String() string { return proto.CompactTextString(m) }
func (*UninstallRequest) ProtoMessage()    {}
func (*UninstallRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{8}
}
func (m *UninstallRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UninstallRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UninstallRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UninstallRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UninstallRequest.Merge(m, src)
}
func (m *UninstallRequest) XXX_Size() int {
	return m.Size()
}
func (m *UninstallRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UninstallRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UninstallRequest proto.InternalMessageInfo

// PeerJoinRequest is request to join from a remote peer.
type PeerJoinRequest struct {
	// Addr is the peer address as host:port
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Config specifies the peer's runtime configuration
	Config *RuntimeConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// SystemInfo describes the peer's environment
	SystemInfo           []byte   `protobuf:"bytes,3,opt,name=system_info,json=systemInfo,proto3" json:"system_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerJoinRequest) Reset()         { *m = PeerJoinRequest{} }
func (m *PeerJoinRequest) String() string { return proto.CompactTextString(m) }
func (*PeerJoinRequest) ProtoMessage()    {}
func (*PeerJoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{9}
}
func (m *PeerJoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerJoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerJoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerJoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerJoinRequest.Merge(m, src)
}
func (m *PeerJoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *PeerJoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerJoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PeerJoinRequest proto.InternalMessageInfo

func (m *PeerJoinRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *PeerJoinRequest) GetConfig() *RuntimeConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *PeerJoinRequest) GetSystemInfo() []byte {
	if m != nil {
		return m.SystemInfo
	}
	return nil
}

// PeerLeaveRequest is a request a peer sends when it wants to leave the cluster
type PeerLeaveRequest struct {
	// Addr is the peer address as host:port
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Config specifies the peer's runtime configuration
	Config *RuntimeConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// SystemInfo describes the peer's environment
	SystemInfo           []byte   `protobuf:"bytes,3,opt,name=system_info,json=systemInfo,proto3" json:"system_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerLeaveRequest) Reset()         { *m = PeerLeaveRequest{} }
func (m *PeerLeaveRequest) String() string { return proto.CompactTextString(m) }
func (*PeerLeaveRequest) ProtoMessage()    {}
func (*PeerLeaveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56ede974c0020f77, []int{10}
}
func (m *PeerLeaveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerLeaveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerLeaveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerLeaveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerLeaveRequest.Merge(m, src)
}
func (m *PeerLeaveRequest) XXX_Size() int {
	return m.Size()
}
func (m *PeerLeaveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerLeaveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PeerLeaveRequest proto.InternalMessageInfo

func (m *PeerLeaveRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *PeerLeaveRequest) GetConfig() *RuntimeConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *PeerLeaveRequest) GetSystemInfo() []byte {
	if m != nil {
		return m.SystemInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.ExecOutput_FD", ExecOutput_FD_name, ExecOutput_FD_value)
	proto.RegisterEnum("proto.LogEntry_Level", LogEntry_Level_name, LogEntry_Level_value)
	proto.RegisterType((*ShutdownRequest)(nil), "proto.ShutdownRequest")
	proto.RegisterType((*CommandArgs)(nil), "proto.CommandArgs")
	proto.RegisterMapType((map[string]string)(nil), "proto.CommandArgs.EnvEntry")
	proto.RegisterType((*Message)(nil), "proto.Message")
	proto.RegisterType((*ExecStarted)(nil), "proto.ExecStarted")
	proto.RegisterType((*ExecCompleted)(nil), "proto.ExecCompleted")
	proto.RegisterType((*Error)(nil), "proto.Error")
	proto.RegisterType((*ExecOutput)(nil), "proto.ExecOutput")
	proto.RegisterType((*LogEntry)(nil), "proto.LogEntry")
	proto.RegisterMapType((map[string]string)(nil), "proto.LogEntry.FieldsEntry")
	proto.RegisterType((*UninstallRequest)(nil), "proto.UninstallRequest")
	proto.RegisterType((*PeerJoinRequest)(nil), "proto.PeerJoinRequest")
	proto.RegisterType((*PeerLeaveRequest)(nil), "proto.PeerLeaveRequest")
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor_56ede974c0020f77) }

var fileDescriptor_56ede974c0020f77 = []byte{
	// 816 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xdd, 0x6e, 0xdc, 0x44,
	0x14, 0xf6, 0x4f, 0xbc, 0x59, 0x1f, 0xa7, 0x89, 0x19, 0x95, 0x60, 0x6d, 0x50, 0x08, 0x56, 0x2f,
	0x22, 0x15, 0x1c, 0x48, 0x11, 0xa5, 0x15, 0x5c, 0xa4, 0xc9, 0x46, 0x0b, 0x0a, 0x2a, 0x9a, 0xb4,
	0xe2, 0x72, 0xe5, 0xb5, 0x8f, 0x8d, 0x85, 0xed, 0xd9, 0xda, 0xe3, 0x25, 0x79, 0x07, 0x1e, 0xa0,
	0x6f, 0xc0, 0x05, 0x2f, 0xc2, 0x25, 0x8f, 0x80, 0xc2, 0x8b, 0xa0, 0x19, 0x8f, 0x77, 0xdd, 0x6d,
	0x17, 0x89, 0x1b, 0xae, 0xf6, 0xfc, 0x7d, 0xe7, 0x7c, 0x3e, 0xdf, 0xce, 0x01, 0x27, 0x4c, 0xb1,
	0xe4, 0xc1, 0xbc, 0x62, 0x9c, 0x11, 0x4b, 0xfe, 0x8c, 0x0e, 0x52, 0xc6, 0xd2, 0x1c, 0x4f, 0xa4,
	0x37, 0x6b, 0x92, 0x13, 0x2c, 0xe6, 0xfc, 0xb6, 0xad, 0x19, 0xed, 0xc5, 0x59, 0x1d, 0xb1, 0x05,
	0x56, 0x2a, 0xe0, 0x3f, 0x84, 0xbd, 0xeb, 0x9f, 0x1a, 0x1e, 0xb3, 0x5f, 0x4a, 0x8a, 0xaf, 0x1a,
	0xac, 0x39, 0xf1, 0x60, 0x3b, 0xca, 0x31, 0x2c, 0x9b, 0xb9, 0xa7, 0x1f, 0xe9, 0xc7, 0x43, 0xda,
	0xb9, 0xfe, 0xef, 0x3a, 0x38, 0xe7, 0xac, 0x28, 0xc2, 0x32, 0x3e, 0xab, 0xd2, 0x9a, 0x10, 0xd8,
	0x0a, 0xab, 0xb4, 0xf6, 0xf4, 0x23, 0xf3, 0xd8, 0xa6, 0xd2, 0x26, 0x1f, 0xc3, 0x4e, 0x8d, 0x79,
	0x32, 0x8d, 0xda, 0x3a, 0xcf, 0x90, 0x2d, 0x1c, 0x11, 0x53, 0x50, 0xf2, 0x29, 0x98, 0x58, 0x2e,
	0x3c, 0xf3, 0xc8, 0x3c, 0x76, 0x4e, 0x0f, 0x5a, 0x22, 0x41, 0xaf, 0x6f, 0x30, 0x2e, 0x17, 0xe3,
	0x92, 0x57, 0xb7, 0x54, 0xd4, 0x8d, 0xbe, 0x84, 0x61, 0x17, 0x20, 0x2e, 0x98, 0x3f, 0xe3, 0xad,
	0xe4, 0x65, 0x53, 0x61, 0x92, 0xfb, 0x60, 0x2d, 0xc2, 0xbc, 0x41, 0x39, 0xc8, 0xa6, 0xad, 0xf3,
	0xd4, 0xf8, 0x4a, 0xf7, 0x5f, 0x1b, 0xb0, 0xfd, 0x3d, 0xd6, 0x75, 0x98, 0x22, 0x79, 0x0c, 0x3b,
	0x78, 0x83, 0xd1, 0xb4, 0xe6, 0x61, 0xc5, 0x31, 0x96, 0x0d, 0x9c, 0x53, 0xa2, 0x66, 0x8f, 0x6f,
	0x30, 0xba, 0x6e, 0x33, 0x13, 0x8d, 0x3a, 0xb8, 0x72, 0xc9, 0x37, 0xb0, 0x2b, 0x81, 0x11, 0x2b,
	0xe6, 0x39, 0x0a, 0xa8, 0x21, 0xa1, 0xf7, 0x7b, 0xd0, 0xf3, 0x2e, 0x37, 0xd1, 0xe8, 0x3d, 0xec,
	0x07, 0xc8, 0x17, 0x20, 0xbb, 0x4d, 0x59, 0xc3, 0xe7, 0x0d, 0xf7, 0x4c, 0x89, 0x7d, 0xaf, 0x87,
	0x7d, 0x2e, 0x13, 0x13, 0x8d, 0x02, 0x2e, 0x3d, 0x12, 0x80, 0x9d, 0xb3, 0x74, 0x8a, 0xe2, 0x93,
	0xbd, 0x2d, 0x89, 0xd9, 0x53, 0x98, 0x2b, 0x96, 0xca, 0x4d, 0x4c, 0x34, 0x3a, 0xcc, 0x95, 0x4d,
	0x1e, 0x80, 0x85, 0x55, 0xc5, 0x2a, 0xcf, 0x92, 0xb5, 0x3b, 0x5d, 0x7f, 0x11, 0x9b, 0x68, 0xb4,
	0x4d, 0x3e, 0xb3, 0x61, 0x1b, 0x73, 0x2c, 0xb0, 0xe4, 0xfe, 0x18, 0x9c, 0xde, 0x37, 0x8b, 0xad,
	0xd6, 0xf8, 0x4a, 0x2e, 0xc5, 0xa2, 0xc2, 0x5c, 0x2a, 0x6b, 0xf4, 0x94, 0x75, 0x57, 0xb2, 0xd9,
	0x52, 0x19, 0x7f, 0x06, 0xf7, 0xde, 0xf8, 0xfe, 0x77, 0x34, 0x3a, 0x00, 0x1b, 0x6f, 0x32, 0x3e,
	0x8d, 0x58, 0xdc, 0x4a, 0x64, 0xd1, 0xa1, 0x08, 0x9c, 0xb3, 0x18, 0x89, 0xdf, 0xf1, 0x36, 0xdf,
	0xe6, 0xad, 0x58, 0xfb, 0x4f, 0xc0, 0x92, 0xbe, 0xf8, 0x5b, 0x16, 0xad, 0x9a, 0x4a, 0xfe, 0xce,
	0x25, 0xfb, 0x30, 0xe0, 0x55, 0x18, 0x61, 0x47, 0x57, 0x79, 0xfe, 0x02, 0x60, 0xb5, 0xe2, 0x77,
	0x70, 0x7b, 0x00, 0x46, 0xd2, 0xea, 0xb9, 0xfb, 0x86, 0x9e, 0x2d, 0x20, 0xb8, 0xbc, 0xa0, 0x46,
	0x12, 0x8b, 0x55, 0xc4, 0x21, 0x0f, 0x25, 0xc7, 0x1d, 0x2a, 0x6d, 0xff, 0x43, 0x30, 0x2e, 0x2f,
	0x08, 0xc0, 0xe0, 0xfa, 0xc5, 0xc5, 0xf3, 0x97, 0x2f, 0x5c, 0x4d, 0xd9, 0x63, 0x4a, 0x5d, 0xdd,
	0xff, 0xd5, 0x80, 0x61, 0xa7, 0xd3, 0xbf, 0xd0, 0x7e, 0x04, 0x83, 0x24, 0xc3, 0x3c, 0x6e, 0x69,
	0xaf, 0x5e, 0x42, 0x07, 0x0d, 0x2e, 0x65, 0xb6, 0x7d, 0x09, 0xaa, 0x94, 0x3c, 0x04, 0x2b, 0xc7,
	0x05, 0xe6, 0x92, 0xce, 0xee, 0xe9, 0xfb, 0xeb, 0x98, 0x2b, 0x91, 0xa4, 0x6d, 0x4d, 0x6f, 0x31,
	0x5b, 0xfd, 0xc5, 0x8c, 0x9e, 0x80, 0xd3, 0xeb, 0xfd, 0x9f, 0x1e, 0xd5, 0xe7, 0x60, 0xc9, 0x11,
	0xc4, 0x06, 0xeb, 0x02, 0x67, 0x4d, 0xea, 0x6a, 0x64, 0x08, 0x5b, 0xdf, 0x96, 0x09, 0x73, 0x75,
	0x61, 0xfd, 0x18, 0x56, 0xa5, 0x6b, 0x88, 0xb4, 0x94, 0xcd, 0x35, 0x7d, 0x02, 0xee, 0xcb, 0x32,
	0x2b, 0x6b, 0x1e, 0xe6, 0xb9, 0xba, 0x31, 0x3e, 0x87, 0xbd, 0x1f, 0x10, 0xab, 0xef, 0x58, 0xb6,
	0x3c, 0x3b, 0xe2, 0x2f, 0x17, 0xc7, 0x95, 0xa2, 0x21, 0x6d, 0xf2, 0x09, 0x0c, 0x22, 0x56, 0x26,
	0x59, 0xba, 0xf6, 0xea, 0x68, 0x53, 0xf2, 0xac, 0xc0, 0x73, 0x99, 0xa3, 0xaa, 0x86, 0x7c, 0x04,
	0x4e, 0x7d, 0x5b, 0x73, 0x2c, 0xa6, 0x59, 0x99, 0x30, 0x25, 0x18, 0xb4, 0x21, 0x41, 0xd0, 0x6f,
	0xc0, 0x15, 0x53, 0xaf, 0x30, 0x5c, 0xe0, 0xff, 0x37, 0xf6, 0xf4, 0x37, 0x03, 0xac, 0x33, 0x71,
	0xa8, 0xc9, 0x53, 0x18, 0x76, 0xd7, 0x96, 0xec, 0xab, 0xa6, 0x6b, 0xe7, 0x77, 0xb4, 0x1f, 0xb4,
	0x07, 0x3c, 0xe8, 0x0e, 0x78, 0x30, 0x16, 0x07, 0x9c, 0x3c, 0x06, 0xeb, 0x6c, 0xc6, 0x2a, 0x4e,
	0x36, 0x14, 0x6c, 0x04, 0x9e, 0xc0, 0x76, 0x77, 0x79, 0xc9, 0xdb, 0xc7, 0x76, 0xb4, 0xab, 0x62,
	0xea, 0x54, 0x7e, 0xa6, 0x0b, 0x96, 0x9d, 0x38, 0x4b, 0x96, 0x6b, 0x6a, 0x6d, 0x1c, 0xf6, 0x35,
	0xd8, 0xcb, 0x15, 0x93, 0x0f, 0x7a, 0xe0, 0xfe, 0xd2, 0x37, 0xa1, 0x9f, 0xb9, 0x7f, 0xdc, 0x1d,
	0xea, 0x7f, 0xde, 0x1d, 0xea, 0x7f, 0xdd, 0x1d, 0xea, 0xaf, 0xff, 0x3e, 0xd4, 0x66, 0x03, 0x59,
	0xf1, 0xe8, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xae, 0x10, 0xba, 0x84, 0xea, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AgentClient interface {
	// Shutdown requests the agent to shut down
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Abort requests the agent to clean up the state on this node and shut down
	Abort(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	// Command executes a command specified with CommandArgs.
	// The output of the command is streamed as a result.
	Command(ctx context.Context, in *CommandArgs, opts ...grpc.CallOption) (Agent_CommandClient, error)
	// PeerJoin receives a connection from a peer.
	// The peer configuration allows this agent to establish a reverse
	// connection to the remote peer to execute remote commands
	PeerJoin(ctx context.Context, in *PeerJoinRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// PeerLeave receives a "leave" request from a peer and initiates its shutdown
	PeerLeave(ctx context.Context, in *PeerLeaveRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.Agent/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Abort(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.Agent/Abort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Command(ctx context.Context, in *CommandArgs, opts ...grpc.CallOption) (Agent_CommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Agent_serviceDesc.Streams[0], "/proto.Agent/Command", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentCommandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_CommandClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type agentCommandClient struct {
	grpc.ClientStream
}

func (x *agentCommandClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) PeerJoin(ctx context.Context, in *PeerJoinRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.Agent/PeerJoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) PeerLeave(ctx context.Context, in *PeerLeaveRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.Agent/PeerLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServer is the server API for Agent service.
type AgentServer interface {
	// Shutdown requests the agent to shut down
	Shutdown(context.Context, *ShutdownRequest) (*types.Empty, error)
	// Abort requests the agent to clean up the state on this node and shut down
	Abort(context.Context, *types.Empty) (*types.Empty, error)
	// Command executes a command specified with CommandArgs.
	// The output of the command is streamed as a result.
	Command(*CommandArgs, Agent_CommandServer) error
	// PeerJoin receives a connection from a peer.
	// The peer configuration allows this agent to establish a reverse
	// connection to the remote peer to execute remote commands
	PeerJoin(context.Context, *PeerJoinRequest) (*types.Empty, error)
	// PeerLeave receives a "leave" request from a peer and initiates its shutdown
	PeerLeave(context.Context, *PeerLeaveRequest) (*types.Empty, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Agent/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Abort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Abort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Agent/Abort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Abort(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Command_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CommandArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).Command(m, &agentCommandServer{stream})
}

type Agent_CommandServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type agentCommandServer struct {
	grpc.ServerStream
}

func (x *agentCommandServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_PeerJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).PeerJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Agent/PeerJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).PeerJoin(ctx, req.(*PeerJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_PeerLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).PeerLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Agent/PeerLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).PeerLeave(ctx, req.(*PeerLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Shutdown",
			Handler:    _Agent_Shutdown_Handler,
		},
		{
			MethodName: "Abort",
			Handler:    _Agent_Abort_Handler,
		},
		{
			MethodName: "PeerJoin",
			Handler:    _Agent_PeerJoin_Handler,
		},
		{
			MethodName: "PeerLeave",
			Handler:    _Agent_PeerLeave_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Command",
			Handler:       _Agent_Command_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}

func (m *ShutdownRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShutdownRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cleanup {
		dAtA[i] = 0x8
		i++
		if m.Cleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandArgs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SelfCommand {
		dAtA[i] = 0x10
		i++
		if m.SelfCommand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x1a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			i = encodeVarintAgent(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAgent(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAgent(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Element != nil {
		nn1, err := m.Element.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Message_ExecStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExecStarted != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.ExecStarted.Size()))
		n2, err := m.ExecStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Message_ExecCompleted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExecCompleted != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.ExecCompleted.Size()))
		n3, err := m.ExecCompleted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Message_ExecOutput) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExecOutput != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.ExecOutput.Size()))
		n4, err := m.ExecOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Message_LogEntry) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogEntry != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.LogEntry.Size()))
		n5, err := m.LogEntry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Message_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Error.Size()))
		n6, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *ExecStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Seq))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecCompleted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Seq))
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.ExitCode))
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Error.Size()))
		n7, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Traces) > 0 {
		for _, s := range m.Traces {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Seq))
	}
	if m.Fd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Fd))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0x12
			i++
			v := m.Fields[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			i = encodeVarintAgent(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAgent(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAgent(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Level))
	}
	if len(m.Traces) > 0 {
		for _, s := range m.Traces {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UninstallRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UninstallRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerJoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerJoinRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Config.Size()))
		n8, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.SystemInfo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.SystemInfo)))
		i += copy(dAtA[i:], m.SystemInfo)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerLeaveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerLeaveRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgent(dAtA, i, uint64(m.Config.Size()))
		n9, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.SystemInfo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgent(dAtA, i, uint64(len(m.SystemInfo)))
		i += copy(dAtA[i:], m.SystemInfo)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAgent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ShutdownRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cleanup {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.SelfCommand {
		n += 2
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Element != nil {
		n += m.Element.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message_ExecStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecStarted != nil {
		l = m.ExecStarted.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *Message_ExecCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecCompleted != nil {
		l = m.ExecCompleted.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *Message_ExecOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecOutput != nil {
		l = m.ExecOutput.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *Message_LogEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogEntry != nil {
		l = m.LogEntry.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *Message_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}
func (m *ExecStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovAgent(uint64(m.Seq))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovAgent(uint64(m.Seq))
	}
	if m.ExitCode != 0 {
		n += 1 + sovAgent(uint64(m.ExitCode))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Traces) > 0 {
		for _, s := range m.Traces {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovAgent(uint64(m.Seq))
	}
	if m.Fd != 0 {
		n += 1 + sovAgent(uint64(m.Fd))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if m.Level != 0 {
		n += 1 + sovAgent(uint64(m.Level))
	}
	if len(m.Traces) > 0 {
		for _, s := range m.Traces {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UninstallRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerJoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.SystemInfo)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerLeaveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.SystemInfo)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAgent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgent(x uint64) (n int) {
	return sovAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShutdownRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShutdownRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShutdownRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cleanup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfCommand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfCommand = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAgent
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAgent
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAgent
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAgent
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAgent(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAgent
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Element = &Message_ExecStarted{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecCompleted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecCompleted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Element = &Message_ExecCompleted{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Element = &Message_ExecOutput{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Element = &Message_LogEntry{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Element = &Message_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecCompleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			m.Fd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fd |= ExecOutput_FD(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAgent
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAgent
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAgent
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAgent
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAgent(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAgent
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= LogEntry_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UninstallRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UninstallRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UninstallRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerJoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerJoinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerJoinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &RuntimeConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemInfo = append(m.SystemInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.SystemInfo == nil {
				m.SystemInfo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerLeaveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerLeaveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerLeaveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &RuntimeConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemInfo = append(m.SystemInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.SystemInfo == nil {
				m.SystemInfo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAgent
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAgent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAgent
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgent   = fmt.Errorf("proto: integer overflow")
)
